\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gestalt.info
@settitle Gestalt - A comprehensive Common Lisp Web Framework

@set VERSION 0.1
@set DATE November 2009

@c Version and Contact Info
@set MAINTAINERSITE @uref{http://common-lisp.net/project/gestalt, maintainers webpage}
@set AUTHOR Mariano Montone
@set MAINTAINER Mariano Montone
@set MAINTAINEREMAIL @email{marianomontone at gmail dot com}
@set MAINTAINERCONTACT @uref{mailto:marianomontone at gmail dot com,contact the maintainer}
@c %**end of header

@ifinfo
@format
START-INFO-DIR-ENTRY
* Gestalt: (gestalt.info). A comprehensive Common Lisp Web framework.
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@c Subheadings inside a table.
@macro tsubheading{text}
@ifinfo
@subsubheading \text\
@end ifinfo
@ifnotinfo
@item @b{\text\}
@end ifnotinfo
@end macro

@copying

This manual is for Gestalt Web Framework version @value{VERSION}.

Copyright @copyright{} 2009, 2010 Mariano Montone

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.
@end quotation
@end copying

@titlepage
@title Gestalt
@subtitle A comprehensive Common Lisp Web Framework
@subtitle Release @value{VERSION}
@author by Mariano Montone

@c Output the table of contents at the beginning.
@contents

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top Gestalt - A comprehensive Common Lisp Web Framework

This is Gestalt Common Lisp Web Framework documentation

@end ifnottex

@menu
* Introduction::                What is Gestalt?
* Web application programming:: What does Web application programming consists of?
* Programming with Gestalt::    How does Web application programming feel like with Gestalt?
* Third-party libraries::       Gestalt's third-party libraries
* Standard applications::       Gestalt's resources for programming standard applications
* Examples::                    Gestalt applications examples
* Tools::                       Tools that help with Gestalt applications development
* System reference::            System reference
* References::                  Related work
* Index::                       Complete index.

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Summary::                     A brief summary of what Gestalt is
* Installation::                How to install Gestalt
* Feedback::                    Bug reports, ideas, patches etc.
* Conventions::                 Type-setting conventions in the manual

Web application programming

* Web application programming overview::  A brief summary of Web application programming
* Problems::                              The problems of Web application programming
* MVC in the Web::                        The Model-View-Controller in the Web

Programming with Gestalt

* Gestalt programming overview::          A brief summary of Web application programming with Gestalt
* MVC in Gestalt::                        How Gestalt approaches the MVC architecture
* The model::                             The Web application bussiness objects in Gestalt
* Model overview::                        An overview of what's the model like in Gestalt
* Why an object database?::               An explanation of why we stick to an object database
* Defining model objects::                How to define Gestalt model objects
* Objects validation::                    How model validation is done in Gestalt
* Consistent objects::                    What consistent objects are.
* Objects that require arguments::        How to define objects that require arguments
* The Elephant object database::          An overview of the Elephant object database
* The controller::                        The Web application controller in Gestalt
* Controller overview::                            The application controller in Gestalt overview
* Programming with components::                    How programming with components feels like.
* Application composition::     How to embed components inside other
* Widgets::                     Widgets overview
* Call and answer semantics::   How we control the application flow?
* Component wrappers::          What are component wrappers
* Javascript components::       Components that have javascript
* Components and libraries::    Components and libraries
* Continuations::                                  What continuations are
* Continuations and web applications programming:: How are continuations used in web applications development
* Continuations and components::                   How are continuations and components related
* Model objects validation::                       How the controller deals with model objects validation errors
* Interaction modes::                              The three interaction modes
* Synchronous interaction mode::                   The synchronous interaction mode
* Asynchronous interaction mode::                  The asynchronous interaction mode
* Bidirectional interaction mode::                   The bidirectional interaction mode
* View updates::                                   How the view gets updated
* View update overview::                           An overview of how the view gets updated
* Dataflow extensions::                            Summary of the dataflow programming extensions in Gestalt
* Dataflow and memory management::                              A brief description on how the memory in managed under dataflow
* The dynamic environment::                        Section about the dyanmic environment and what we can do with it
* Component threads and database transactions::    Component threads and database transactions overview
* Context Oriented Programming::                   Context Oriented Programming overview
* Layered components::                             Layered components overview
* The view::                   The Web application view in Gestalt
* View overview::              An overview of how the view is approached in Gestalt
* Defining a template::        The Gestalt template system overview
* Template assignment::        How templates get assigned to components
* Template elements::          Template elements
* Templates and scope::        Scope and template definitions
* Template combinations::      How templates can be combined
* Custom templates::           How to define your own class of templates
* Built-in templates classes:: Short reference of the already defined template classes
* Template backends::              Template backends overview
* Built-in template backends::     The built-in template backends
* SEXP template backend::          The SEXP template backend
* XMLisp template backend::        The XMLisp template backend
* HTML template backend::          The HTML template backend
* TRFM template backend::          The TRFM  template backend
* User defined template backends:: How to define your own template backends
* GUI types::                      The types of GUI
* HTML GUI type::                  The HTML GUI type
* XUL GUI type::                   The XUL GUI type
* GTK GUI type::                   The GTK GUI type

Third-party libraries
* First-class URLs::       Library that provides first-class URLs management
* Consistent objects::     consistent-object library reference
* Dataflow::               Dataflow library reference
* Utilities::              Utilities library (copying objects, doubly-linked lists, etc)

Standard applications

* Authenticated applications:: How to program the application login?
* Access control::             How to do permission checking
* Standard widgets::           The standard widgets
* Objects meta editors::       Generating objects editors reflectively

Examples

Tools

* SLIME::                     The Superior Lisp Interaction Mode for Emacs
* LSB::                       Domain Specific Lisp System Browser for Emacs
* Database administrator::    Manage the application's model
* Configuration::             How to configure a Gestalt application
* Debugging::                 How to debug Gestalt applications
* Inspector::                 The web inspector
* Profiling::                 How to profile Gestalt applications
* Deployment::                How to deploy a Gestalt application

System References

References

Index

@end detailmenu
@end menu

@node Introduction
@chapter Introduction
Gestalt is yet another Common Lisp Web framework. Its purpose is to both try to make simple things simple and investigate new ideas in Web development.

  You can get a copy and this manual at @url{http://common-lisp.net/project/gestalt}

@menu
* Summary::                     A brief summary of what Gestalt is
* Installation::                How to install Gestalt
* Feedback::                    Bug reports, ideas, patches etc.
* Conventions::                 Type-setting conventions in the manual
@end menu

@node Summary
@section Summary
@cindex summary

This is Gestalt summary...

@node Installation
@section Installation
@cindex installation

To install gestalt, start a Common Lisp session and type the following:

@example
CL-USER> (require :asdf-install)
CL-USER> (asdf-install:asdf-install 'gestalt)
@end example

@node Feedback
@section Feedback
@cindex feedback

Mail marianomontone at gmail dot com with feedback

@node Conventions
@section Conventions
@cindex conventions

Hear are some coding conventions we'd like to follow:

@itemize

@bullet{We @emph{do} believe in documentation. Document your dynamic variables, functions, macros and classes. Besides, provide a documentation from a wider perspective. Provide diagrams and arquitecture documentation; examples and tutorials, too. Consider using an automatic documentation generator (see the bitacora package in the dependencies).}

@bullet{We don't want functions to be shorter than the should nor longer than they should. There is no "every function should have at most ten lines of code" rule. We think that coding is like literature to a great extent. So you should strive for beauty and clarity. Again, that your code is object oriented doesn't imply that your methods will ideally have two lines of code and dispatch to somewhere else; that is not always good at all. It may be good from an object oriented point of view, but it is too low level. We want to think in terms of languages, that is higher level,  instead of objects sending messages.}

@bullet{Use destructuring-bind or let or a pattern-matching library instead of car, cdr, cadr, and the like to obtain more readable code.}

@bullet{Use widely known Common Lisp coding guidelines: @url{http://web.archive.org/web/20050305123711/www.lisp.org/table/style.htm}}

@end itemize

@node Web application programming
@chapter Web application programming
@cindex web programming

Web application programming is like this...

@menu
* Web application programming overview::  A brief summary of Web application programming
* Problems::                              The problems of Web application programming
* MVC in the Web::                        The Model-View-Controller in the Web
@end menu

@node Web application programming overview
@section Web application programming overview

Web application programming is like this

@node Problems
@section Problems
@cindex web programming, problems of

The problems with Web application programming are these...

@node MVC in the Web
@section MVC in the Web
@cindex mvc

The MVC in the Web is like this...

@node Programming with Gestalt
@chapter Programming with Gestalt

Web application programming with Gestalt is like that...

@menu
* Gestalt programming overview::          A brief summary of Web application programming with Gestalt
* MVC in Gestalt::                        How Gestalt approaches the MVC architecture
* The model::                             The Web application bussiness objects in Gestalt
* The controller::                        The Web application controller in Gestalt
* The view::                              The Web application view in Gestalt
@end menu

@node Gestalt programming overview
@section Gestalt programming overview
@cindex gestalt, programming in
@cindex gestalt, overview

   Gestalt applications follow a MVC architecture. At the model layer, the framework is designed to work with an optimistic object database; that's because implicit saving of objects and long transactions are needed by the rest of the parts of the framework.

   At the controller level, we use a component based approach, a lot like the @url{http://seaside.st} Seaside framework; dataflow semantics for view updating.

   Finally, at the view level, we use a flexible and conveniente template engine and a set of widgets.

@node MVC in Gestalt
@section MVC in Gestalt
@cindex mvc

MVC in Gestalt is like this...

@node The model
@section The model

@menu
* Model overview::                 An overview of what's the model like in Gestalt
* Why an object database?::        An explanation of why we stick to an object database
* Defining model objects::         How to define Gestalt model objects
* Objects validation::             How model validation is done in Gestalt
* Consistent objects::             What consistent objects are.
* Objects that require arguments:: How to define objects that require arguments
* The Elephant object database::   An overview of the Elephant object
@end menu

@node Model overview
@subsection Model overview
@cindex model

The model in a Gestalt application is based on an object database...

@node Why an object database?
@subsection Why an object database?
@cindex object database

    We persist objects in an object database because, on the one hand, our framework architecture relies on being able to store objects implicitly; that means, it is important for composability not to do explicit call to a save method on objects. Object database provide just this; they let us save objects implicitly just adding them to some root object. This let's us preserve composability.

    On the other hand, we need optimistic transactions. This is not a unique object database feature, but available RDBMs do not provide this in general, and the object database we are using does.

@node Defining model objects
@subsection Defining model objects

@node Objects validation
@subsection Objects validation
@cindex validation

Ideally, all validation should be done at the model level, not in the view or the controller.
So, first, every model object is supposed to have a validate method. For example:

@example
(defmethod validate ((person person))
  (check (name person)
         (and (stringp (name person))
	      (> (length (name person)) 0)))
  (check (lastname person)
         (and (stringp (lastname person))
	      (> (length (lastname person)) 0))))
@end example

That provides some server side validation for model objects, and is necesary to ensure objects are consistent (See model object consistency section).

But a more complex validation framework is provided by means of rules, extensible types, some syntax and client and server side validation implementation.

@example
(defmodel user ()
   ((username :initarg :username
              :required t
              :error-msg (lambda (user)
                             (format nil "Username should be provided for ~A" user))
              :type :string
              :validate (:unique :error-msg (lambda (user username)
                                                (format nil "~A is already taken" username))))))
@end example

Or maybe, we should provide validation spec, directly in the type. Example:

@example
(defmodel user ()
   ((username :initarg :username
              :required t
              :error-msg (lambda (user)
                             (format nil "Username should be provided for ~A" user))
              :type (:string (:unique :error-msg (lambda (user username)
                                                (format nil "~A is already taken" username)))))))
@end example

@emph{:unique} is a defined validator, like this:

@example
(define-validator unique (value)
   (check-attribute-value-unique-in-db value))
@end example

Validators can be configured from the components (controllers). So, if we want a simple validation, we don't have to do anything. When the user tries to create or save a user object, the validation fails, so it has to display the errors and let the user correct them. But we can also validate through ajax, when the user leaves the userame input. For example:

@example
(defcomponent user-creator ()
   ((model :initarg :model
           :accessor model))
   (:initialize ()
       (-> add-component (make-instance 'text-input-adaptor :model (username (-> model))
                                                            :on-lose-focus (let ((username-validator (attribute-validator (-> model) 'username)))
                                                                                (funcall username-validator (-> model) 'username))))))
@end example

And it is also posible to validate attributes on the client side. For example:
@example
(defmodel person ()
   ((age :initarg :age
         :required nil
         :type (:range 1 120))
    (email :initarg :email
           :required t
           :type :email)))
@end example

Both, @emph{:range} and @emph{:email} types have client-side vaidation implementations:

@example
;; Server side validation implementation
(define-validator :range (value type)
     (and (> (from type) value)
          (< value (to type))))

;; Client side validation implementation
(define-client-validator :range (value type)
     ;; javascript generation here
     (ps (and (> (from type) value)
          (< value (to type)))))
@end example

The @emph{:email} validators implementation is very similar.

Then, we can specify client side validation in our components:

@example
(defcomponent person-creator ()
   ((model :accessor model))
   (:initialize ()
     (-> add-component :age (make-instance 'range-input-adaptor :validation :client))))
@end example

@node Consistent objects
@subsection Consistent objects
@cindex consistent objects

@example
(defclass person ()
  ((name :initarg :name
	 :accessor name
	 :initform "")
   (lastname :initarg :lastname
	     :accessor lastname
	     :initform ""))
  (:metaclass consistent-object-class)
  (:documentation "A person"))

(defmethod validate ((person person))
  (ensure (and (stringp (name person))
	       (> (length (name person)) 0))
	  "Provide a name for ~A" person)
  (ensure (and (stringp (lastname person))
	       (> (length (lastname person)) 0))
	  "Provide a lastname for ~A" person))

(test consistent-object-test
      ;; The following fails:
      (signals consistency-error
	       (make-instance 'person))
      ;; The following fails:
      (signals consistency-error
	(let (person)
	  (suspending-consistency-for (person)
	    (setf person (make-instance 'person))
	    (setf (name person) "Mariano")
	    person)))

      ;; The following fails:
      (signals consistency-error
	       (let ((person (make-instance 'person)))
		 (setf (name person) "Mariano")
		 (setf (lastname person) "Montone")))

      ;; The following works:
      (finishes
	(let (person)
	  (suspending-consistency-for (person)
	    (setf person (make-instance 'person))
	    (setf (name person) "Mariano")
	    (setf (lastname person) "Montone")
	    person)))

      ;; Test the result is correct:
      (let (person)
	(let ((p (suspending-consistency-for (person)
		   (setf person (make-instance 'person))
		   (setf (name person) "Mariano")
		   (setf (lastname person) "Montone")
		   person)))
	  (is (name p) "Mariano")
	  (is (lastname p) "Montone"))))
@end example

@node Objects that require arguments
@subsection Objects that require arguments
@cindex required arguments

@example
(defclass person ()
  ((name :initarg :name :required t)
   (lastname :initarg :lastname :required t :error-msg "Please give me a lastname!!")
   (phone :initarg :phone :initform "" :required nil)
   (address :initarg :address :initform ""))
  (:metaclass required-slots-class)
  (:documentation "The class definition to test required slots"))

(defmethod print-object ((person person) stream)
  (print-unreadable-object (person stream :type t :identity t)
    (format stream "name: ~A lastname: ~A phone: ~A address: ~A"
	    (slot-value person 'name)
	    (slot-value person 'lastname)
	    (slot-value person 'phone)
	    (slot-value person 'address))))

(test required-slots-class-test
  (signals required-slot-error (make-instance 'person))
  (signals required-slot-error (make-instance 'person :name "Mariano"))
  (signals required-slot-error (make-instance 'person :lastname "Montone"))
  (finishes (make-instance 'person :name "Mariano" :lastname "Montone"))
  (signals required-slot-error (make-instance 'person :address "Mi casa")))
@end example

@node The Elephant object database
@subsection The Elephant object database
@cindex elephant database
@cindex object database

@node The controller
@section The controller
@cindex controller

@menu
* Controller overview::                            The application controller in Gestalt overview
* Programming with components::                    How programming with components feels like.
* Continuations::                                  What continuations are
* Model objects validation::                       How the controller deals with model objects validation errors
* Interaction modes::                              The three interaction modes
* View updates::                                   How the view gets updated
* Dataflow extensions::                            Summary of the dataflow programming extensions in Gestalt
* The dynamic environment::                        Section about the dynamic environment and what we can do with it
@end menu

@node Controller overview
@subsection Controller overview
@cindex controller

@node Programming with components
@subsection Programming with components
@cindex components
@menu
* Application composition::     How to embed components inside other
* Widgets::                     Widgets overview
* Call and answer semantics::   How we control the application flow?
* Component wrappers::          What are component wrappers
* Javascript components::       Components that have javascript
* Components and libraries::    Components and libraries
* Application navigation and bookmarking::  Application navigation and bookmarking
* URL format::                  How the url is formatted
@end menu

@node Application composition
@subsubsection Application composition
@cindex composition

Wow!! add-child doen't take a component, it is a macro and takes a block of code (that corresponds to the concurrent control flow). It is the fork equivalent!! Great...

Sketchy implementation:

@example
(defmacro add-child (component slot &rest body)
  (once-only (component)
	     `(setf (slot-value ,slot ,component)
		    (make-instance 'child-component-handler
				   :name (symbol-name ,slot)
				   :parent ,component
				   :go (lambda (self)
					 ,@@body)))))

(defmethod call ((self child-component-handler) other-component &rest args)
  "call redefinition for child components calling"
  ;; set which is the child component (we need that, the template system needs to know which are the child components, for example)
  (setf (component self) component)
  ;; invoque the original call operation
  (prim-call self comp args))

(defmacro simple-add-child (component slot child-component)
  "Adds a child-component without 'threading code' complications"
  `(add-child ,component ,slot
	      (call ,child-component)))
@end example

child-component-handler may be designed as a subclass of task as it has a :go lambda.
It is different from a task because we need to redefine the call method on it in order to indicate
which is the new child component in the slot.

tasks are components with a :go lambda.

(defclass task (component)
  ((go :initarg :go :accessor go)))

Note: task components or variations of them may act as component-wrappers and/or child-component-handlers. Think about that.

We can extend this idea of child "components" and consider "building the whole component tree from lambdas"

About "component tree from lambdas":
-------------------------------

We can build the component tree from lambdas. The semantics of some of the operations depends on what kind of component we are building.

For example, to declare the main component, we could have:

@example
(defapplication my-application ()
  ())

(defvar *application* nil "The running application")
@end example

;; We use defmethod/cc. We need continuations for component calling, and dynamic environment restoring (contextl) so that dynamic variables and
;; other structures continue to make sense in presence of continuations.

@example
(defmethod/cc start-application :around ((app application))
   (let
       ((*application* app))
     (dflet ;; dynamic functions binding
         ((call (component)  ; the semantics of the call operation depends on the context (in this case we are setting the root component)
	      (set-root-component *application* component)))
	 (call-next-method))))

(defmethod/cc start-application ((app my-application))
  ;; now, this is an example of how we can specify the root component of our application
  (loop while t
       do (let ((user (call (make-instance 'login-component))))
	    (set-logged-user user)
	    (call (make-instance 'main-component))
	    (unlog-user))))
@end example

Other example, is the semantics of call when adding child components.

@node Widgets
@subsubsection Widgets

In Gestalt, components control the navigation flow and set up connections to the view and application model. Views are HTML or XML depending of the type of view, plus some references to widgets. We can have different kind of widget for the same connections; the API is respected. So, for example, suppose we want user input from an integer range. Then, we set up the connections:

@example
(defcomponent range-component ()
   ((model :initarg :model
           :documentation "An integer adaptor")
   (:initialize ()
        (<- set-child :range (make-widget-adaptor 'range-adaptor
                                  :range '(1 10)
                                  :model (-> model))))))
@end example

So, a range-adaptor was created. Now, from the view, we can select the widget we want to use for that adaptor. The widget has to be compatible with the adaptor, and implement the correct api. A widget behaves differently depending on the adaptor it is being used with.

@example
(defview range-component ()
   (:p (str "The range component"))
   (widget :range :slider))
@end example

And we get a javascript slider, from 1 to 10.

We can set options to the widgets, for example, if we want the slider to be vertical instead of horizontal, or setup some options:
@example
(defview range-component ()
   (:p (str "The range component"))
   (widget :range :slider
           :color :blue
           :orientation :horizontal))
@end example

Or, we may want to use a text input. The text input semantics under the range-adaptor is to prevent input other that the numbers in the range (by javascript). As we have already said, widgets behave differently depending on the adaptor attached.

@example
(defview range-component ()
   (:p (str "The range component"))
   (widget :range :text-input
           :style "background:blue"))
@end example

So, what matters to the component is setting up the right connections (adaptors); what widgets are going to be used and where, that goes in the view.

Another example could be a multiselection:
@example
(defcomponent multiselect-component ()
   ((source :initarg :source
            :documentation "A list")
    (model :initarg :model
           :documentation "A list adaptor"))
   (:initialize ()
        (<- set-child :multiselect (make-widget-adaptor 'multiselect-adaptor
                                     :source (-> source)
                                     :model (-> model)))))
@end example

And then we choose the widget. The standard way, and HTML select with multiselect on (multiselect is activated automatically when the select widget works with a multiselect adaptor). Again, widgets behave differently depending on the adaptor they are attached to.

@example
(defview multiselect-component ()
   (:p (str "The multiselect component"))
   (widget :multiselect :select))
@end example

Or a more complex widget:

@example
(defview multiselect-component ()
   (:p (str "The multiselect component"))
   (widget :multiselect :jquery.ui-multiselect))
@end example

Another example is a simple item selection:

@example
(defcomponent select-component ()
   ((source :initarg :source
            :documentation "A list")
    (model :initarg :model
           :documentation "Contains the selected element of the list"))
   (:initialize ()
        (<- set-child :select (make-widget-adaptor 'select-adaptor
                                  :source (-> source)
                                  :model (-> model)))))
@end example

And then in the view we can use a tranditional select box:
@example
(defview select-component ()
   (:p (str "The select component"))
   (widget :select :select))
@end example

Or a list box:
@example
(defview select-component ()
   (:p (str "The select component"))
   (widget :select :list-box))
@end example

Or text input. Under a select-adaptor, the text-input autocompletes the available options through AJAX:
@example
(defview select-component ()
   (:p (str "The select component"))
   (widget :select :text-input))
@end example

@node Call and answer semantics
@subsubsection Call and answer semantics
@cindex call
@cindex answer

When an active component calls another, it loses its control and passes it to the called component. The called component becomes the active one.

If an unactive component answers, then an error is raised (although proper restarts are available).

If an unactive component calls another, then an error is raised (although proper restarts are available).

If a child component calls another, then it loses focus, and the called one gains control.

If a child component answers an object, then it desappears from the screen. The parent can set a callback on it to intercept the child component answer. Child components multiply the flow of control. Continuation passing doesn't hold anymore in their presence. Example:

@example
(defmethod initialize :after ((component my-component) &rest initargs)
  (declare (ignore initargs))
  (add-child (component first-child)
   (format t "This is the first flow of control")
   (let ((answer (call (make-instance 'my-child-component)))) ;; This embeds and sets the child component
     ;; The answer
     (format t "The first child component answered ~A" answer)))
  (add-child (component second-child)
   (format t "This is the second flow of control")
   (let ((answer (call (make-instance 'my-child-component)))) ;; This embeds and sets the child component
     ;; The answer
     (format t "The second child component answered ~A" answer))))
@end example

@node Component wrappers
@subsubsection Component wrappers
@cindex wrappers

Implement component-wrappers (should be the equivalent of :after :before :around and other method combinations for methods).

component-wrappers should alter the behaviour of a component (for example, its rendering), but should remain transparent to some machinery (for example, the templating engine assignment policy should be independent of component-wrappers. component-wrappers are invisible to the template-engine).

Use case:

We can use component-wrappers to build complex objects editors. In general, an object editor should not contain an accept and cancel button, because that depends on the context. So, the following is incorrect:

@example
(defcomponent person-editor ()
  ((name :type :input :model (name model))
   (lastname :type :input :model (lastname model))
   (accept :type :button :on-click (accept-edition self))      <-- The accept button should not belong to the editor
   (cancel :type :button :on-click (cancel-edition self))))    <-- The cancel button should not belong to the editor
@end example

The problem with this design is that it is difficult to build more complex editors from existent ones.

@example
(defcomponent artist-editor ()
  ((artistic-name :type :input :model (artistic-name model))
   (art :type :input :model (art model))
   (accept :type :button :on-click (accept-edition self))      <-- The accept button should not belong to the editor
   (cancel :type :button :on-click (cancel-edition self))))    <-- The cancel button should not belong to the editor
@end example

The problem is that person-editor and artist-editor are not incompatible by design, but we are adding the accept and cancel button twice.

A possible solution is to use component-wrappers:

@example
(defcomponent-wrapper editor-wrapper ()
  (:render (component wrapper)
	   (call-next-method)    ; We render the component
	   ; We render the accept and cancel buttons once.
	   (accept :type :button :on-click (accept-edition self))
	   (cancel :type :button :on-click (cancel-edition self))))

(defmethod call ((wrapper editor-wrapper))
  ; We wrap the editor call
  (with-transaction
      (call (component wrapper))))
@end example

And with transaction should expand to something similar to:

@example
(unwind-protect
     (tagbody edition-block
	(restart-case (progn
			(begin-transaction)
			(call (component wrapper))
			(commit-stm-transaction))
	  (retry-edition ()
	    :report (lambda (stream)
		      (format stream "Restart the edition"))
	    ;; This is all. It's responsibility of the piece of code that
	    ;; throws errors to provide other restarts, such as :continue, for example.
	    (rollback-transaction)
	    (go edition-block))
	  (abort-edition ()
	    :report (lambda (stream)
		      (format stream "Abort the edition"))
	    (rollback-transaction))))
  (when (transaction-active)
    (rollback-transaction)))
@end example

THIS IS WHY WE NEED TO ADAPT DYNAMIC LANGUAGE CONSTRUCTS TO COMPONENT CHAINING!!

Finally, under this scheme, the editor component should commit anything on accept, and raise a signal (versioning-error, etc) on error.

@node Javascript components
@subsubsection Javascript components
@cindex javascript

Now we apply free-variables detection to build a javascript-server comunication library

@example

(defcomponent my-object-deleter ()
  ()
  (:initialize ()
	       (let ((object (model self)))
		 (add-action-link :name "delete-object"
				  :default-display "Delete object"
				  :action
				  (client
				   ;; The free variable "object" is passed to the client
				   (if (open-dialog 'question-dialog :text (format nil "Are you sure you want to delete ~A?" object))
				       (server
					;; Now the free variable "object" refers to the client proxy. The client passes de object id
					(delete-object object))))
				)
	       )
  ))

;; Different identifyable lambdas should be created in both sides, in the client and the server. We assign an id to each of them and call them distributely (RPC)

;; For example, for the above example, we have two lambdas:

  In the client:
  (create-lambda (object)
		 (if (open-dialog 'question-dialog :text (format nil "Are you sure you want to delete ~A?" object))
		     (call-server :session 4 :id 44 :params object)))

  In the server:
  (create-lambda (object)
		 (delete-object object))

  And the resulting action is:
  (let ((object (model self)))
		 (add-action-link :name "delete-object"
				  :default-display "Delete object"
				  :action (call-client :session *session* :id 33 :params object)))

  Besides, the javascript to create lambdas is dynamically transferred when the component is active

  |#

(defclass component ()
  ((children :accessor children :initform '()))
  )

(defclass widget ()
  ()
  )

(defclass action-link (widget)
  ((name :accessor name :initarg :name)
   (default-display :accessor default-display :initarg :default-display)
   (action :accessor action :initarg :action)))

(defvar *server-entry-counter* 1)
(defvar *server-entries* (make-hash-table :test #'equal))

(defvar *client-entry-counter* 1)
(defvar *client-entries* (make-hash-table :test #'equal))


(defun register-server-entrypoint (exp)
  (let ((entry-id *server-entry-counter*)
	(freevars (list-free-vars (list exp))))
    (incf *server-entry-counter*)
    (values
     entry-id
     freevars
    `(setf (gethash ,entry-id *server-entries*)
	  (lambda ,freevars ,exp)))))

(defun register-client-entrypoint (exp)
  (let ((entry-id *client-entry-counter*)
	(freevars (list-free-vars (list exp))))
    (incf *client-entry-counter*)
    (values
     entry-id freevars
     `(setf (gethash ,entry-id *client-entries*)
				     (lambda ,freevars, exp)))))

(defvar *in-server-context* t)
(defvar *client-lambdas* '())
(defvar *server-lambdas* '())

(defun process-action (code)
  (labels
	((process-tree (exp)
	   (if (atom exp)
	       exp
	       (let ((operation (car exp))
		     (args (cdr exp)))
		 (case operation
		   (server
		     (if *in-server-context*
			 `(progn
			    ,@@(mapcar #'process-tree args))
			 (call-server `(progn ,@@args))))
		   (client
		    (if *in-server-context*
			(call-client `(progn ,@@args))
			`(progn
			   ,@@(mapcar #'process-tree args))))
		   (let
		       (let
			   ((bindings (car args))
			    (body (cdr args)))
			 `(let
			      ,(loop for binding in bindings
				  for form = (cadr binding)
				  collect
				    (list (car binding) (process-tree form)))
			    ,(process-tree `(progn ,@@body)))))
		   (let*
		       (let
			   ((bindings (car args))
			    (body (cdr args)))
			 `(let*
			     ,(loop for binding in bindings
				 for form = (cadr binding)
				 collect (list (car binding) (process-tree form)))
			 ,(process-tree `(progn ,@@body)))))
		   (flet
		       (let
			   ((bindings (car args))
			    (body (cdr args)))
			 `(flet
			      ,(loop for binding in bindings
				  for fbody = (nth 2 binding)
				  collect (list (car binding) (cadr binding) (process-tree `(progn ,@@fbody))))
			    ,(process-tree `(progn ,@@body)))))
		   (labels
		       (let
			   ((bindings (car args))
			    (body (cdr args)))
			 `(labels
			      ,(loop for binding in bindings
				  for fbody = (nth 2 binding)
				  collect (list (car binding) (cadr binding) (process-tree `(progn ,@@fbody))))
			    ,(process-tree `(progn ,@@body)))))
		   (return-from
		    (error "Unimplemented"))
		   (t
		    `(,operation ,@@(mapcar #'process-tree args)))))))
	 (call-server (code)
	   (let ((*in-server-context* t))
	     ;; Register a server-entry-point from the code
	     (multiple-value-bind (id parameters lambdas-code)
		 (register-server-entrypoint (process-tree code))
	       (push lambdas-code *server-lambdas*)
	       ;; Return the code that calls it
	       `(server-call ,id ,@@parameters))))
	 (call-client (code)
	   (let ((*in-server-context* nil))
	     (multiple-value-bind (id parameters lambdas-code)
		 (register-client-entrypoint (process-tree code))
	       (push lambdas-code *client-lambdas*)
	       ;; Return the code that calls it
	       `(client-call ,id ,@@parameters)))))
	 (process-tree code)))

(defun process-action-2 (code)
  (let
      ((*in-server-context* nil)
       (*client-lambdas* '())
       (*server-lambdas* '())
       (*client-entry-counter* 1)
       (*server-entry-counter* 1))
    (let ((action-code (process-action code)))
      (values action-code
	      `(progn ,@@*server-lambdas*)
	      (compile-script `(progn ,@@*client-lambdas*))))))

;; Test

;; (process-action-2 '(progn (let ((chau "chau")) (client (print "hola" obj) (server (print "hola" chau) (client (print "hi")))))))

(defmacro add-action-link (c &key name default-display action)
  (multiple-value-bind
	(action-code server-lambdas client-lambdas)
      (process-action-2 (macroexpand action))
    `(progn
       (push (make-instance 'action-link :name ,name :default-display ,default-display :action (lambda () ,(compile-script action-code))) (children ,c))
       ,server-lambdas
       ,client-lambdas)))

#| Test:


(add-action-link my-component
		 :name "my-component"
		 :default-display "My Component"
		 :action (progn (print "hola" obj) (server (let ((chau "chau")) (print "hola" chau) (client (print "hi") (print chau))))))
@end example

Problema con esta version de add-action-link: es estrictamente necesario hacer una conversión CPS por cada operacion server y client. Esto es así ya que, en el caso de un rendering standard, el código a continuar debe ir en un atributo onLoad del tag body. En el caso de Ajax, el codigo a continuar debe ir de forma similar atacheado a un objeto HttpRequest en forma de callback. Una particularidad de esta conversión es que debe tener en cuenta las variables libres para saber exactamente que variables vamos pasando del servidor al cliente y del cliente al servidor (no tenemos ni un stack reificado (interprete) ni un stack implícito con bindings en memoria (lambdas + frames))

@node Components and libraries
@subsubsection Components and libraries
@example
;; First-class libraries.

;; Libraries are first class objects in the framework. They should have a unique name. We don't implement dependencies between them yet.
;; You can declare component library dependencies per component

(defvar *libraries* (make-hash-table :test #'equalp) "Defined libraries mapped by name")


(defclass library ()
  ((url :accessor url :initform (error "Provide the library URL") :documentation "The URL to access the library")
   (dependencies :accessor dependencies :initform '() :documentation "Others libraries this depends on")
   ))

(defclass library-class (standard-class)
  ()
  )

(defmacro deflibrary (name &rest options)
  `(defclass ,name ()
     ,@@options
     (:metaclass 'library-class)))

(defmethod shared-initialize ((library library) &rest initargs)
  (declare (ignore initargs))
  ;; Register the defined library
  (setf (class-name ))

  )


;; Example:

(deflibrary prototype
    :url "/lib/prototype.js")

(deflibrary scriptaculous
    :url "/lib/scriptaculous.js"
    :dependencies '(prototype))

;; And then we can use it in our components

;; scriptaculous-component mixin
(defcomponent-mixin scriptaculous-component-mixin ()
  (:libraries '(scriptaculous)))

;; defcomponentmixin should create a non instanciable class and append its libraries to its subclasses
;; so we can do

(defcomponent my-scriptaculous-component (scriptaculous-component-mixin)
  ...
  )

;; Besides, we should get rid of circularities and repetition when building the main page. The main page required scripts are determined from the components handling repetition and circularity.
@end example

@node Application navigation and bookmarking
@subsubsection Application navigation and bookmarking
@cindex navigation
@cindex bookmarking
@cindex bookmarks
@cindex url

The bookmarking problem is difficult to solve in the context of a complex Web application. In particular, it is not clear how to obtain a particular state of the application from a simple bookmarking string. Besides, there are some states of the application that cannot and should not be reached by bookmarking. That's the case of a user session navigation (content that is available to a logged user only) or a commercial transaction, for example. So, first, we must identify the parts of the application that are reachable by bookmarking. Second, we must provide a framework that allows us to do that as simply and naturally as possible.

One approach to solve the problem, would be to map the application as a state transition machine, identify the navigational paths, and apply a tag to each one of them. But we've already seen that determine each of the states is not desirable in complex Web applications. So we'd better find a better approach.

Discarding the state machine, there are at least two more possibilities to solve the problem:

One would be to register the components calling chain. The advantages are: we can repeat the navigation chain to reach any state. The disadvantages are: the chain of components gets large depending of how much time the user has been navigating. That is to say, how many transitions the user caused. On the other hand, there's room for a lot of unnecesary applications transitions; a same state could have been reached with less transitions. This is because this solution is not mapping a multiple input (components transition) to a unique output (a declarative application state specification). [See the next section for a generalized explanation of this problem].

The other option is to register pertinent navigation layers and component states to reach the desired state. Bookmarks have a declarative taste, like this.

@example
bookmark = layers=layer1:layer2+collection-navigator-1:offset=22:segment=22... etc
@end example

Each component should define how to be restored given some parameters. Some components may be uninteresting to restore, once more, depending on the context.

Bookmarking configuration: we can have three ways of configuring a component.
@enumerate
From the component itself (subclasses, mixins, class definition).
@example
(defcomponent collection-navigator ()

  (:bookmarking (offset :accessor bm-offset) ;; bm-offset is used to extract the offset in bookmarking format. (setf bm-offset) is used to set the component offset from a bookmarking parameter)
		(segment :accessor bm-segment))
  (:bookmark :all))
@end example

From the outside.
@example
(with (make-instance 'collection-navigator :on my-collection)
      (disable-bookmarking-of 'segment it)
      (call it))
@end example

From the outside, dynamically. It may be useful if we don't want to bookmark certain embedded subcomponent nor any of its components.
@example
(with (make-instance 'my-complex-component)
      (disabling-bookmarking
       (call it)))
@end example
@end enumerate

@node URL format
@subsubsection URL format
@cindex url

Syntax:
@example
url ::= host/path?[session]&[continuation]&[bookmark]
session ::= _s=session-id
continuation ::= _c=continuation-id
@end example

Arguments and values:
@example
@itemize
session-id -- The session id
continuation-id -- The continuation id
bookmark -- @ref{Application navigation and bookmarking}
@end itemize
@end example

Semantics:

If the session-id is present, then: if the continuation-id is present, the continuation is executed. If the continuation is not in the server in that session (it may have expired or have been stored as part of a bookmark), then there's an attempt to restore the application state from the bookmark parameters. If that cannot be done, then the request fails.

If the continuation-id is present, but the session-id is not, then there's an attempt to restore the application from the bookmarks.

@node Continuations
@subsection Continuations
@cindex continuation

@menu
* Continuations and web applications programming:: How are continuations used in web applications development
* Continuations and components::                   How are continuations and components related
@end menu

@node Continuations and web applications programming
@subsubsection Continuations and web applications programming

@node Continuations and components
@subsubsection Continuations and components

@node Model objects validation
@subsection Model objects validation
@cindex validation

@node Interaction modes
@subsection Interaction modes
@cindex interaction modes
@menu
* Synchronous interaction mode::                   The synchronous interaction mode
* Asynchronous interaction mode::                  The asynchronous interaction mode
* Bidirectional interaction mode::                 The bidirectional interaction mode
@end menu

@node Synchronous interaction mode
@subsubsection Synchronous interaction mode
@cindex synchronous interaction mode

This is the standard interaction mode

@node Asynchronous interaction mode
@subsubsection Asynchronous interaction mode
@cindex asynchronous interaction mode

This is the AJAX mode

@node Bidirectional interaction mode
@subsubsection Bidirectional interaction mode
@cindex bidirection interaction mode

This is the COMET mode

@node View updates
@subsection View updates
@cindex update, view

@menu
* View update overview::                           An overview of how the view gets updated
@end menu

@node View update overview
@subsubsection View update overview

@node Dataflow extensions
@subsection Dataflow extensions
@cindex dataflow

@menu
* Dataflow and memory management::                              A brief description on how the memory in managed under dataflow
@end menu

@node Dataflow and memory management
@subsubsection Dataflow and memory management
@cindex memory management, dataflow and

I have thought dataflow extensions to be used with a garbage collector. That means, you should use weak-references most of the time, and strong-referencing and explicit memory deallocation in exceptional cases. For example, you may want to respond to some event in some object, but you may not be interested in that object itself. So you want to reference the object strongly because it would be gone otherwise. REVISE THIS PREVIOUS SENTECES.

@node The dynamic environment
@subsection The dynamic environment
@cindex environment
@cindex dynamic environment

@menu
* Component threads::                              What component threads are
* Example - Programming a login::                  A login example
* Component expansion::                            Component expansion
* Component threads and database transactions::    Component threads and database transactions overview
* Context Oriented Programming::                   Context Oriented Programming overview
* Layered components::                             Layered components overview
* A COP example::                                  An example of COP in action
@end menu

@node Component threads
@subsubsection Component threads
@cindex threads, component

Child threads are aborted if the parent is aborted. For example, if the user hits the logout button of the root component, all of the child components are aborted before aborting the root component.

So, for example:

@example
(defapplication my-application ()
  ())

(defmethod/cc start-application ((app my-application))
  ;; now, this is an example of how we can specify the root component of our application
  (loop while t
       do (let ((user (call (make-instance 'login-component))))
	    (set-logged-user user)
	    (call (make-instance 'main-component)) ; **
	    (unlog-user))))
@end example

When the user hits the logout button of the main-component, the main-component child threads are aborted before proceeding. Note that aborting a child component may lead to some behaviour. For example, if the child component is an editor that is configured to ask for cancellation in case the user leaves the component. Then, trying to logout, will raise the cancelling exception and a dialog box asking for cancellation will appear; the user will not be able to logout without asking. Now, that's ok, but it would be interesting to think how we can control that. For example, we may want the editor to avoid asking the question in case we hit the logout button, but ask it otherwise. It's not clear how to achieve that with a "threading" semantics. Possible solution??: the logout button activates a layer. That layer should deactivate the abort-condition catch up that shows the dialog, and provide some that just proceeds with the editor abortion. Not trivial anyway...but interesting.

Not that the components threads semantics is preemtive; the parent component may abort nested components.

Implementation thought: we may implement dynamic environments manual setting using ContextL dynamic-environments manipulation library. Then, each component would hold its own dynamic layer (or environment). The user should be able to control whether he wants to restore some dynamic environments or not. In the logout case, we don't want to restore the aborted component (editor) dynamic environment; we want to treat signaled conditions differently (for example, avoiding a question dialog, and proceeding instead). If the user leaves, or hits cancel, then we *do* want to restore the components dynamic environment.

Sketch:

Suppose we have A as the parent of B. B calls C for performing some operation.
@example
(defmethod initialize-instance :after ((comp A) &rest initargs)
  (add-child comp
	...
   (call comp 'B)
     ...
   ))

;; add-child should get translated to the following:
(let ((env (dynamic-environment comp)))
  (with-dynamic-environment env ;; the parent component dynamic-environment
    (dynamic-wind     ;; This *should* compose the local environment with the above one
     ...
     (proceed
      (let ((child (make-instance 'B)))
	(setf (environment child) (capture-dynamic-environment))
	(effectively-add-child child)))
     ...)))

(defaction accept-action ((comp B))
  ...
  (call 'C)
  ...)

; should be translated to something like:
(let ((env (dynamic-environment comp)))
  (with-dynamic-environment env ;; the parent component dynamic-environment
    (dynamic-wind     ;; This *must* compose the local environment with the above one
     ...
     (proceed
      (let ((calle (make-instance 'B)))
	(setf (environment calle) (capture-dynamic-environment))
	(effective-call calle)))
     ...)))

;; Note:
;; First: the code before and after the call (...) is part of the dynamic winding (altough if we have continuations "there's no after code").
;; Second: with-dynamic-environment pushes the reevaluated thunks to the stack so we get an augmented dynamic environment when we call capture-dynamic-environment. So, now we have component threads dynamic-environments. So, for example, component threads dynamic variables can be accesed like this:

(defdynamic my-var 33)
(defdynamic parent-var 22)

;; Luego podemos acceder esa variable con (dynamic my-var) en el scope generado a través de la inyección de environments en los componentes:

(defmethod initialize-instance :after ((comp A))
  (add-child comp
    (dynamic-let
       ((parent-var 45))
         (call 'B))))

(defaction accept-action ((comp B))
  (dynamic-let
    ((my-var 55))
      (call 'C)))

(defmethod initialize-instance :after ()
    (print (dynamic parent-var)) ;; This prints 45!! (component thread variable!)
    (print (dynamic my-var))) ;; This prints 55
@end example

@emph{An example of thread semantics:}

Queremos mostrar una lista y cada vez que hacemos click sobre uno de sus elementos, queremos abrir un editor en la parte de abajo de la pantalla:

@example
(defaction initialize ((comp main-component))
  (add-child comp 'elements
   (let ((list-component (make-instance 'collection-navigator :on *elements*)))
     (on-click list-component
	       (lambda (element)
		 (add-child comp 'element-editor
			    (with-transaction
				(call (make-instance 'element-editor :on element)))))))))
@end example

Entonces, cada vez que el usuario hace click en un elemento, se corre el thread para agregar el editor de elementos. Si hay un editor mostrandose, entonces se aborta el thread. La forma de abortar el thread es recuperando el contexto dinámico asociado a la continuación del thread y hacer un (signal 'abort-thread) (no se ejecuta la continuación) bajo ese contexto. En este ejemplo, se estaŕia ejecutando el unwind-protect de with-transaction. En otro caso, se podría interrumpir la cancelación del thread, y preguntar por la cancelación de la edición, por ejemplo así:

@example
(defaction initialize ((comp main-component))
  (add-child comp 'elements
   (let ((list-component (make-instance 'collection-navigator :on *elements*)))
     (on-click list-component
	       (lambda (element)
		 (add-child comp 'element-editor
			    (with-transaction
				(handler-case
				    (call (make-instance 'element-editor :on element))
				  (abort-thread (e)
				    (when (call (make-instance 'message-box :text "Cancelar edición del elemento?"))
				      (signal e))))))))
     (call list-component)))) ;; re-signal the condition  ;; we do nothing other wise (the component remains in place)
@end example

Problema: cómo tratar a with-transaction bajo extensión dinámica??: No queremos ejecutar with-transaction cada vez; queremos reutilizar la transacción bindeada en rucksack:*transaction*!! We should redefine it something like:

@example
(defmacro with-transaction% (&rest body)
  (with-gensyms (transaction)
    `(with-transaction
	 (let ((,transaction rucksack:*transaction*)) ; ,transaction should not be dynamically bound
	 (component-dynamic-wind
	  (let ((rucksack:*transaction* ,transaction))
	    (proceed ,@@body)))))))

(defmacro record-vars (vars &rest body)
  "Records dynamically bound variables in the compoenent dynamic-environment"
  (with-gensyms (proceed)
    (let ((gensyms (mapcar #'gensym vars)))
      `(let
	   ,(loop for var in vars
	       for gensym in gensyms
	       collect `(,gensym ,var))
	 (component-dynamic-wind ,proceed
         	 (let
		     ,(loop for var in vars
			 for gensym in gensyms
			 collect `(,var ,gensym)))
		 (,proceed ,@@body))))))

(defmacro with-dtransaction (&rest body)
  `(with-transaction
       (record-vars (rucksack::*transaction*)
		    ,@@body)))

(defmacro with-dactive-layers (&rest body)
  `(with-active-layers
       (record-vars (contextl::*active-context*)
		    ,@@body)))
@end example

@node Example - Programming a login
@subsubsection Example - Programming a login
@cindex login

Dynamic extent and user login:
------------------------------

If we have dynamic-extent reexecution semantics, then we can add a check for the logged user in the continuation, like this:

@example
(defaction start ((app my-app))
  (let (person)
    (block login
      (loop while t
	 when person do (return)
	 do (setf person (call (make-instance 'login-component)))))
    ;; We begin the session: these ones should be executed once only!! (shouldnt be part of the dynamic-environment)
    (proceed
     (begin-session)
     (set-logged-user person))
    ;; We make a dynamic check
    (if (current-session)
	(call 'main-component)
	;; else, we want the dialog to appear under the dynamic-extent
	(call-component 'message-dialog :text "You have to login to do that!"))))
@end example

Maybe we should design our own operators to introduce dynamic-environments:

@example
(defmacro my-handler-case (expr cases)
  (with-gensyms (new-env proceed)
    `(with-dynamic-environment ((dynamic-environment (component)))
       (let ((,new-env
	      (dynamic-wind ,proceed
			    (handler-case
				(,proceed expr)
			      ,cases))))
	 (setf (dynamic-environment (component)) new-env)))))
@end example

De esta forma, tenemos que todo se ejecuta una sola vez, solo determinadas partes. Además, deberíamos tener un component-dynamic-wind mejor:

@example
(defmacro component-dynamic-wind (&rest body)
  `(with-dynamic-environment ((dynamic-environment (component)))
     (let ((,new-env
	    (dynamic-wind ,@@body)))
       (setf (dynamic-environment (component)) new-env))))
@end example

Y así nos queda:

@example
(defmacro dhandler-case (expr cases)
  (with-gensyms (proceed)
    `(component-dynamic-wind ,proceed
			     (handler-case
				 (,proceed expr)
			       ,cases))))
@end example

Y el login queda:

@example
(defaction start ((app my-app))
  (let (person)
    (loop while t
       when person do (return)
       do (setf person (call (make-instance 'login-component))))
    ;; We begin the session: these ones should be executed once only!! (shouldnt be part of the dynamic-environment)
    (begin-session)
    (set-logged-user person)
  ;; We make a dynamic check. This dynamic check affects all the components from the main-component ;)
    (component-dynamic-wind
     (if (current-session)
	 (proceed (call 'main-component))
	 ;; else, we want the dialog to appear under the dynamic-extent
	 (call 'message-dialog :text "You have to login to do that!")))))
@end example

@node Component expansion
@subsubsection Component expansion
@cindex expansion

Components are supposed to be modal in the sense that they replace other components when are displayed. Now, how to determine the components that should be replaced. That is to say, what is the extent of a modal component? We can determine that with component nesting (or, in our case, with dynamic extent control, that is supposed to be equivalent in our framework).

Sketch:

Top level expansion handler:
@example
(defmethod initialize :around ((component my-component) &rest initargs)
  (if (not (parent component))
      ;; This is the root component. Handle and accept the expansion
      (handler-bind
	  ((expand-component-request
	    (lambda (request)
	      (invoke-restart 'expand-component-with-limit component))))
	(call-next-method))
      ; else
      (call-next-method)))
@end example

Setting up expansion limits when initializing parent component (adding subcomponents):

@example
(defmethod initialize ((component my-component) &rest initargs)
  (handler-bind
    ((expand-component-request (request)
       (if (equalp (component-class request) component)
	   (invoke-restart 'expand-component-with-limit component)
	   (signal request))))
  (add-component 'my-other-component)))
@end example

With macrology:

@example
(defmacro with-expansion-limit ((component))
  (once-only (component)
    (with-gensym (request)
      `(handler-bind
	   ((expand-component-request (,request)
	      (if (equalp (component-class ,request) ,component)
		  (invoke-restart 'expand-component-with-limit ,component)
		  (signal ,request))))))))

(defmethod initialize ((component my-component) &rest initargs)
  (with-expansion-limit (component)
      (add-component component 'my-other-component)))
@end example

@node Component threads and database transactions
@subsubsection Component threads and database transactions
@cindex transactions, component threads and database
@cindex nested transactions

@emph{Nested component transactions semantics:}

If the inner transaction commits, then nothing happens. All the changes are commited iff the top level transaction commits.

If the inner transaction raises an error, or rollbacks, the outer transaction remains untouched. The inner transaction can be retried, and the computation resumes. That's why we have nested transactions; a nesting of transaction doesn't form a new bigger transaction, but the transactions hierarchy is preserved.

If the outer transaction rollbacks, then al changes are discarded, including changes made in inner transactions.

If the outer transaction commits, all the inner transactions must have been commited. If one of them is uncommited, then an error is raised (restart with the option to commit the remaining ones). If all of them are commited, then the outer transaction commits too, and all of the changes are made effective.
Once more, errors should be propagated through the component chain (not through the stack-chain).

@node Context Oriented Programming
@subsubsection Context Oriented Programming
@cindex cop
@cindex context oriented programming

Once dynamic language constructs are adapted, we can start to use context oriented features for our application.

Example:
@example
(deflayer listing-layer () ())

We can layer the controller behaviour:

(def-layered-component :layer listing-layer person-viewer (viewer))

(def-layered-method :layer listing-layer initialize ((viewer person-viewer))
		    ...)
@end example

After that we can do:

@example
(add-child
 (with-active-layers (listing-layer)
   (call (make-instance 'persons-component))))
@end example

It is also possible, and may make sense, to make the template engine context aware:

@example
<template class="person-viewer"
          layer="listing-layer">
   ...
</template>
@end example

@node Layered components
@subsubsection Layered components

@node A COP example
@subsubsection A COP example

For example, let's consider the "promotions" problem. A product promotion is available to certain users for a period of time. Let's try to model it with context layers. So, we have a promotions-layer. When it is active, we want a special promotion component to be displayed on the main-page. So we have:

@example
(defclass main-page ()
  ((banner :component t
	   :initform (make-instance 'label :text "Hello!!. This is the main page")))
  (:metaclass component-class))

(defclass promotion-widget ()
  ((product :initarg :product
	    :reader product))
  (:metaclass component-class))

(contextl:deflayer promotion-layer ()
  ())
@end example

In the promotion-layer, the main-page displays the promotion-widget:

@example
(defclass main-page ()
  ((promotion-widget :component t
		     :initform (make-instance 'promotion-widget :product *product*)))
  (:metaclass component-class)
  (:layer promotion-layer))

<template class="main-page">
  <container id="banner"/>
</template>
@end example

We place the promotion-widget at the top, when the promotions-layer is active. Note the interaction between templates combinations and template options. That should be configurable throgh a MOP. For example, how layered templates behave in presence of template combinations.

@example
<template class="main-page"
          combination="above"
          layer="promotion-layer">
  <container id="promotion-widget"/>
</template>

<template class="promotion-widget">
  ...
</template>
@end example

And the code sketch for activating the layers:

@example
(defun begin-user-session ()
  (dynamic-wind
    (if (active-promotions-for-user-p *user*)
	(contextl:ensure-active-layer 'promotions-layer)
	(contextl:ensure-inactive-layer 'promotions-layer))
    (proceed
     (go-on))))
@end example

We could define a volatile-layer to improve the code:

@example
(deflayer volatile-layer ()
  ()
  (:documentation "This kind of layers are volatile. That means, they are active for some period.
                   We have to implement the valid-layer-p method"))

(defgeneric valid-layer-p (layer &optional period)
  (:documentation "Tells whether a volatile-layer is valid in a period of time")
  (:method ((layer volatile-layer) &optional period)
    (declare (ignore layer period))
    ;; not valid by default
    nil))

(deflayer period-layer (volatile-layer)
  ((from-date-time :initarg :from
		   :reader from-date-time
		   :initform (error "Supply the from date-time"))
   (to-date-time :initarg :to
		 :reader to-date-time))
  (:documentation "A volatile-layer that is valid for a period of time"))

(defmethod valid-layer-p (layer &optional (period (date-time-now)))
  (in-period-p period (cons (from-date-time layer)
			    (to-date-time layer))))

(defmacro with-volatile-layers (layers &body body)
  (with-unique-names (valid-layers invalid-layers)
    `(let (,valid-layers ,invalid-layers)
       (loop for layer in ,layers
	    if (valid-layer-p (find-layer layer))
	      do (push layer ,valid-layers)
	    else do (push layer ,invalid-layers))
        (call-with-active-layers ,valid-layers           ; we need to implement call-with-active-layers in contextl
	  (lambda ()
	    (call-with-inactive-layers ,invalid-layers   ; we need to implement call-with-inactive-layers in contextl
		(lambda ()
	           ,@@body)))))))

(defun begin-user-session ()
  (with-volatile-layers ('promotions-layer)
    (go-on)))
@end example

@node The view
@section The view
@cindex view

@menu
* View overview::              An overview of how the view is approached in Gestalt
* Defining a template::        The Gestalt template system overview
* Template assignment::        How templates get assigned to components
* Template elements::          Template elements
* Templates and scope::        Scope and template definitions
* Template combinations::      How templates can be combined
* Custom templates::           How to define your own class of templates
* Built-in templates classes:: Short reference of the already defined template classes
* Template backends::          Template backends overview
* GUI types::                  The types of GUI
@end menu

@node View overview
@subsection View overview

     We achieve view-model-controller separation by means of templates. In spite of not begin of much use in some frameworks, I think they are indispensible for working with graphic designers.

    In Gestalt, templates are first-class XML entities. They are loaded in memory in your web application, and you can inspect them and modify them incrementally and on the fly.

@node Defining a template
@subsection Defining a template
@cindex templates

To define a template, we use the xml template element syntax:
@itemize
@emph{Syntax:}
@example
<template component-class="[component-class-name]"
          [qualifiers="@{qualifier@}*"]
          [template-metaclass="template-metaclass-name"]
          [options="@{option@}*"]>
   @{xml-element@}*
</template>
@end example

@emph{Arguments and values:}
@itemize
@emph{component-class-name} -- The class name of the child component

@emph{qualifier} -- The template definition qualifiers. In a standard-template-combination, one of @emph{AROUND}, @emph{BELOW}, @emph{ABOVE}. This attribute is optional.

@emph{template-metaclass-name} -- The template metaclass. The template metaclass defines the way the templates qualifiers are interpreted and how the templates are attached to the component. Important restriction: all the templates defined for a particular class of component (you can have different definitions for the same class of component through templates qualifiers) must have the same template-metaclass. If this attribute is not specified, then the template-metaclass used is standard-template-metaclass. This attribute is optional.

@emph{options} -- The options are arbitrary strings consumed by the template-metaclass.
                  The standard templates metaclass supports defining and assigning templates taking into account a component's static context. A component static context is its position in the component tree. For example: given the context @emph{(standard-list person-editor)}, the template engine would assign templates with that context only to standard-lists inside a person-editor. Or, @emph{(standard-list < person-editor)} templates would be assigned to standard-lists that are direct children of a person-editor.
@end itemize
@end itemize

@emph{Description:}
The template xml element defines a template for a certain component class.

@emph{Examples:}
@example
<template class="person">
  <p>Name: </p> <container slot="name"
                           class="label"/>
  <p> Lastname: </p> <container slot="lastname"
                                class="label"/>
</template>
@end example

It is also possible to use non-xml syntax:

@example
(template (:class "person")
  (:p Name:) (:label (:slot "name"))
  (:p Lastname) (:label (:slot "lastname"))
  (next-template))
@end example

@node Template assignment
@subsection Template assignment

@node Template elements
@subsection Template elements

@menu
* Container elements::         Embedding components in templates
* Container classes::          Container classes
* Design alternatives::        Design alternatives for container objects
* Collection elements::        Embedding a collection of elements
@end menu

@node Container elements
@subsubsection Container elements
@cindex container elements
Container elements refer to a model slot. The component slot is supposed to refer to a component or be null. If no component is begin referenced by the slot, then nothing is displayed. If the slot references a component, then a view is searched for it, attached to it, and displayed in the place the container element is found.
@subsubsection Container definition
@itemize
@emph{Syntax:}
@example
<container slot="[slot-name]"
                 [class="container-class"]
       @{attributes@}*/>
@end example

@emph{Arguments and values:}
@itemize
@emph{slot-name} -- The name of the slots that contains the child component.

@emph{container-class-name} -- The name of the container-class.

@emph{attributes} -- A list of xml-attributes specifications that are used by the container-class.
@end itemize

@emph{Example}
@example
<template class="person">
   <container slot="name"/>
   <container slot="lastname"/>
   <container slot="friend"/>
</template>
@end example
@end itemize

@emph{Arguments and values:}

@node Container classes
@subsubsection Container classes
@cindex container classes
@itemize
@emph{Motivation}
When we use a container element to embed a component, the described algorithm is used to match the component view. But what we are trying to embed is a widget, things get a little too rigid. Let's take the following example to see this:
@example
<template class="person">
   <p>Name:</p><container slot="name"/>
   <p>Lastname:</p><container slot="lastname"/>
   <container slot="friend"/>
</template>
@end example
        In this example, we are saying we want the name and lastname of the person embedded, but we are not saying how. Let's suppose we have two Label wslotgets on them, as we are only interested in reading them, not writing the attributes. But we may want to represent that with a read-only text input instead of that. So we may use a container-class read-only-text-input to control that.
@example
<template class="person">
   <p>Name:</p><container slot="name"
                          class="read-only-text-input"/>
   <p>Lastname:</p><container slot="lastname"
                              class="read-only-text-input"/>
   <container slot="friend"/>
</template>
@end example

@emph{Defining container classes:}
@itemize
@emph{Syntax:}
@example
@emph{- Macro:}
   define-container-class name (@{superclasses@}*)
      (@{slots@}*)
      (:compatiblity compatiblity-list)
      [(:render (view-type stream) @{form@}*)]
@end example

@emph{Arguments and values:}
@itemize
@emph{name} -- The name of the container class

@emph{superclasses} -- The classes the container class inherits from

@emph{slots} -- The list of the container class slots

@emph{compatibility-list} -- The list of the other container-classes this container-class is compatible with.
@end itemize

@emph{Description:}
Defines a new container class.

@emph{Examples:}
@example
(define-container-class read-only-text-input (label)
     ()
     (:render (self stream (view-type (:eql 'html)))
                 (with-xml (stream)
                     (input :type "text"
                            :readonly t
                            :value (esc (print-string (model self))))))
             (:compatilibity-list '(label)))
@end example
In this case, the compatibility list indicates that a read-only-tet-input can be used in place of a label.
@end itemize
@end itemize

@node Design alternatives
@subsubsection Design alternatives

Maybe container elements are just too rigid. We can use a container-element mixin and a define-container-element macro and just use the name of the container element in the tag of the xml element.

Example:

@example
(define-container-element text-input ()
           )
@end example

And then:
@example
<template class="person">
   <p>Name:</p><text-input slot="name"
                           read-only="t"/>
   <p>Lastname:</p><container slot="lastname"
                              read-only="t"/>
   <container slot="friend"/>
</template>
@end example

instead of:

@example
<template class="person">
   <p>Name:</p><container slot="name"
                          class="read-only-text-input"/>
   <p>Lastname:</p><container slot="lastname"
                              class="read-only-text-input"/>
   <container slot="friend"/>
</template>
@end example

@node Collection elements
@subsubsection Collection elements
@cindex collection elements

Collection elements are a special kind of container elements. They are used to display collections of components.

@itemize
@emph{Syntax:}
@example
collection-element ::= <collection slot="slot-name"
                                [binding="binding-name"]>
                                @{template-definition@}*
                                @{xml-element | collection-element@}*
                       </collection>
collection-element ::= <collection-element [binding="binding-name"]/>
@end example

@emph{Arguments and values:}
@itemize
@emph{slot-name} -- The name of the slot that contains the collection of components.

@emph{binding-name} -- The name of the variable that binds the collection elements.

@emph{template-definition} -- A local template definition. Collection elements are scoped elements. That means you can define local templates in their bodies.
@end itemize

@emph{Description:}
Collection elements come in two flavors:

@itemize
@emph{Collection elements without body}
This is the easiest and more straightforward way of displaying a collection of elements. We display a collection of component; each component gets a view attached following the standard algorithm.
Example:
@example
<template class="person">
   <p>Name</p><text-input slot="name" style="read-only;"/>
   <p>Lastname</p><text-input slot="lastname" style="read-only;"/>
   <collection slot="friends"/>
</template>
@end example

@emph{Collection elements with body}
This flavor lets the user display the elements of a collection in a particual way. As a collection element is a scoped-element, we can define local templates in the beggining of its body.
Example: we can display a person's friends in a table like this:
@example
<template class="person">
            <p>Name</p><text-input slot="name" style="read-only;"/>
            <p>Lastname</p><text-input slot="lastname" style="read-only;"/>
            <table>
               <tbody>
         <collection slot="friends">
           <template class="person">
               Name: <label slot="name"/> lastname: <label slot="lastname"/>
           </template>
           <tr><collection-element/></tr>
         </collection>
               </tbody>
            </table>
          </template>
@end example

@emph{Collection bindings}
It may be desirable to give collection bindings a name instead of doing it implitly by the standard form of collection-element xml element. This is true in situations we we want to nest two collections of elements. In that case, we can use the 'binding' attribute.
Example:
@example
          <collection slot="friends" binding="friend">
             <collection slot="friend-friend">
           <tr>
             <td><collection-element binding="friend"/>
                 <collection-element binding="friend-friend"/>
             </td>
           </tr>
             </collection>
          </collection>
@end example
@end itemize
@end itemize

@node Templates and scope
@subsection Templates and scope
@cindex scope, templates and
    Some templates elements introduce new scopes. That means we can declare templates that are relevant in the scope of that element only. The most common examples of those elements are template and collection. Those elements may have a list of template definitions in the beggining of their body, before any other type of xml element.

Examples:
@example
    <template class="person">
      <template class="person">
         <p>Friend name:</p><label slot="name"/>
         <p>Friend lastname:</p><label slot="lastname"/>
      </template>
      <p>Name:<p><label slot="name"/>
      <p>Lastname:</p><label slot="lastname"/>
      <container slot="friend"/>
    </template>

    <template class="person">
         <p>Name</p><text-input slot="name" style="read-only;"/>
         <p>Lastname</p><text-input slot="lastname" style="read-only;"/>
         <table>
            <tbody>
              <collection slot="friends">
                <template class="person">
                    Name: <label slot="name"/> lastname: <label slot="lastname"/>
                </template>
                <tr><collection-element/></tr>
              </collection>
            </tbody>
         </table>
       </template>
@end example

Implementation: XML elements that introduce new scopes are inherited from the scoping-template-element class. You can inherit from it when defining your own template elements.

@node Template combinations
@subsection Template combinations
@cindex combinations, template

@menu
* Template combinations overview::         A brief summary of what template combinations are
* Standard template combination::          The standard template combination
@end menu

@node Template combinations overview
@subsubsection Template combinations overview

In order to improve templates composition we provide template combinations. Template combinations are a lot like Common Lisp method combinations and are inspired by them, but for templates. The default template combination in standard-template-combination.

    Template combinations use the qualifiers of the template definition for instantiating the view to the component.

@node Standard template combination
@subsubsection Standard template combination
@cindex standard template combination
    The standard template combination recognizes AROUND, ABOVE  and BELOW qualifiers, corresponding to AROUND, BEFORE and AFTER of standard method combination.

@itemize
@emph{AROUND combination}
      AROUND templates are displayed around the ABOVE, PRIMARY and BELOW templates. Templates embedding is achieved through the element <next-template/>
      Example:
      @example
        <template component-class="person"
           qualifiers="around">
            <div style="background-color:red;">
        <next-template/>
            </div>
        </template>
      @end example
      This makes the person to be displayed inside a red coloured box.

@emph{ABOVE combination}
ABOVE templates are displayed above the PRIMARY template.
   Example:
   @example
        <template class="person"
           qualifiers="above">
            <p>There's a person below this message</p>
        </template>
   @end example

@emph{BELOW combination}
  BELOW templates are displayed below the PRIMARY template
  Example:
  @example
        <template class="person"
           qualifiers="below">
            <p>There's a person above this message</p>
        </template>
  @end example
@end itemize


@node Custom templates
@subsection Custom templates
@cindex custom templates

It is possible to define custom templates through a MOP.

The algorithm to change the way views are assigned to component can be changed creating a new template-metaclass, assigning a new template-combintation to it and defining the appropiate methods. For an example of this, see [Context oriented templates].

@node Built-in templates classes
@subsection Built-in templates classes
@cindex built-in template classes

+ Standard templates
    standard-template-class
+ Context oriented templates
    cop-template-class

@node Template backends
@subsection Template backends
@menu
* Built-in template backends::     The built-in template backends
* User defined template backends:: How to define your own template backends
* SEXP template backend::          The SEXP template backend
* XMLisp template backend::        The XMLisp template backend
* HTML template backend::          The HTML template backend
* TRFM template backend::          The TRFM  template backend
* User defined template backends:: How to define your own template backends
@end menu

There are different template backends (or engines). There's an SEXPressions based backend; an HTML bakend; and a transformations backend.

@node Built-in template backends
@subsubsection Built-in template backends

@node SEXP template backend
@subsubsection SEXP template backend

@example
(deftemplate my-component (:backend :sexp
                           :depends-on (:calendar.js))
  (<div
     (<p (str title))))
@end example

@node XMLisp template backend
@subsubsection XMLisp template backend
@example
(deftemplate my-component (:backend :xmlisp
                           :depends-on (:calendar.js))
  <div>
     <p>
       (str title)
     </p>
  </div>)
@end example

@node HTML template backend
@subsubsection HTML template backend

@example
(deftemplate my-component (:backend (:html #p"./templates/my-component.tpl")
                           :depends-on (:calendar-js)))

--- my-component.tpl ---
<div>
  <p>@{title@}</p>
</div>

@end example

@node TRFM template backend
@subsubsection TRFM template backend
@example
(deftemplate my-component (:backend (:trfm #p"./templates/page.html")
                           :depends-on (:calendar-js))
      (:crop ``/div/div/div[2]'')
      (:replace ``/p[1]/{text}'' title))
@end example

@node User defined template backends
@subsubsection User defined template backends

@node GUI types
@subsection GUI types
@menu
* HTML GUI type::              The HTML GUI type
* XUL GUI type::               The XUL GUI type
* GTK GUI type::               The GTK GUI type
@end menu

@node HTML GUI type
@subsubsection HTML GUI type
@cindex html

@node XUL GUI type
@subsubsection XUL GUI type
@cindex xul

@node GTK GUI type
@subsubsection GTK GUI type
@cindex gtk

@node Third-party libraries
@chapter Third-party libraries
@cindex libraries, third-party
@menu
* Elephant::               The elephant object database
* First-class URLs::       Library that provides first-class URLs management
* Consistent object library::     consistent-object library reference
* Dataflow::               Dataflow library reference
* Utilities::              Utilities library (copying objects, doubly-linked
@end menu

@node Elephant
@section Elephant
@cindex elephant
Embed or link elephant database doc here...

@node First-class URLs
@section First-class URLs
@cindex url

The problem:
------------

Some of the problems I see repeatedly in this and other Web frameworks is the URLs handling. URLs are generally represented as simple strings. That is inconvinient in my opinion. When treating them as strings, concatenating them becomes an issue, specially because of the #\\ character. Besides, matching the action corresponding to the URL it too coupled to how the URL strings are. That makes Web applications configuration and deployment more difficult than it should be.


Proposal:
---------
I propose treating URL as first-class entities, a lot like what CL-FAD http://www.cliki.net/CL-FAD does with pathnames.


Implementation sketch:
----------------------

(help me with the names, I'm not very good at English!)

We can represent URLs with CLOS objects:

@example
(defmacro generic-url (url)
  ((protocol :initarg :protocol
	     :accessor protocol)
   (hostname :initarg :hostname
	     :accessor hostname)
   (path :initarg :hostname
	 :accessor hostname)
   (program :initarg :program
	    :accessor program)
   (parameters :initarg :parameters
	       :accessor parameters
	       :documentation "Property list from ?a1=v1&a2=v2&...&an=vn")
   (fragment :initarg :fragment
	     :accessor fragment))
  (:documentation "A typical URL. Example: protocol://hostname:port/path/program?a1=v1&a2=v2&...&an=vn#fragment"))

(defun concatenate-urls (&rest urls)
  "URLs concatenation (corrent handling of the #\\ character)")

(defun read-url (str)
  "Create a url from a string (used by reader-syntax)")
@end example

We can also define some protocols:

@example
(defvar *url-protocols*
  (make-hash-table :test #'equal))

(defmacro define-url-protocol (name &optional (str `(symbol-name ',name)))
  `(setf (gethash ',name *url-protocols*) ,str))

(define-url-protocol :http)
(define-url-protocol :ftp)
@end example

And finally provide some reader syntax:

@example
#url"http://localhost/myapp/main.do"
@end example

@node Consistent object library
@section Consistent object library
@cindex consistent object

@node Dataflow
@section Dataflow
@cindex dataflow

@node Utilities
@section Utilities
@cindex utilities

@node Standard applications
@chapter Standard applications
@cindex standard applications

@menu
* Authenticated applications:: How to program the application login?
* Access control::             How to do permission checking
* Standard widgets::           The standard widgets
* Objects meta editors::       Generating objects editors reflectively
@end menu

@node Authenticated applications
@section Authenticated applications
@cindex login
@ref{Example - Programming a login}

One thing we would like our authenticated application apart from preventing not logged users from accessing it, is to redirect to the intended url after the user logs in. So, let's suppose the user enters a bookmark, but he should not be able to access the content until he is logged in. We can program that like this:

@example
(defmethod handle-url ((application standard-application))
   ; standard url handling and dispatching)

(defmethod handle-url ((application authenticated-application))
    (loop while (not (logged-in-user))
      do (call 'login))
    (call-next-method)) ;; handle the url after the user has been logged-in
@end example

Note that the original url is handled; that is good! And that it is necessary to start a new session even before the user has logged in; that's because we need to keep track of control flow (the loop continuation), and that needs an active session.

@node Access control
@section Access control
@cindex access control

@example
(add-component 'button (make-instance 'button :action #'some-action)
     :when (let ((model (model self)))
              (df
                 (can-do-some-action model))))
@end example

In this case, the @emph{model} library in the @emph{df} form is free, so it is assumed to be a dataflow variable: whenever the model changes the @emph{can-do-some-action} condition is rechecked  and the component is enabled or disabled accordingly.

@node Standard widgets
@section Standard widgets
@cindex widgets

@node Objects meta editors
@section Objects meta editors
@cindex meta editors
@example
(defclass person ()
   ((name :type :text :validation :required
          :name "Name")
    (lastname :type :text :required
              :name "Last name")
    (birthdate :type :date :nam "Birth date")
    (age :type :number :name "Age")
    (friends :type (:collection 'person) :name "Friends"))
   (:metaclass model-metaclass)
   (:documentation "A person"))
@end example

From that definition, we can have validation (required arguments) and ad-hoc editors and creators, that is inferred from the types of the fields, and database storing too.

@node Examples
@chapter Examples
@cindex examples

@node Tools
@chapter Tools
@cindex tools
@menu
* SLIME::                     The Superior Lisp Interaction Mode for Emacs
* LSB::                       Domain Specific Lisp System Browsing for Emacs
* Database administrator::    Manage the application's model
* Configuration::             How to configure a Gestalt application
* Debugging::                 How to debug Gestalt applications
* Inspector::                 The web inspector
* Profiling::                 How to profile Gestalt applications
* Deployment::                How to deploy a Gestalt application
@end menu

@node SLIME
@section SLIME
@cindex slime

@node LSB
@section LSB
@cindex lsb

LSB is a Domain Specific System Browser for Emacs. That means, you can browse an application in different ways depending on the application.

LSB uses application's metadata to define its views and interfaces. For example, a typical application will contain a configuration section where the user can set configuration parameters, a class browser, a function browser, a macros browser. A web application may contain, a controller, a model and view browser; a database view too. A more advanced application will contain an aspect's browser, a context layers browser, etc.

LSB lets the user get acquainted with the system in less time and makes it easy for the developer to browse the different parts of the system.

Typical views include: a config view, a design view, an implementation view, a ``recent changes'' view, a versioning management view. The user can also define custom views.

The motivation for LSB is that, in general, the different sections and aspects of an application are hidden inside folders and files and classes of an application. LSB makes the different aspects immediatly visible and easily modifiable. For example, Smalltalk browser work at the class level, while LSB works at the application aspect level.

Configuring an application with LSB is a lot easier than with a normal browser as you get specific editors for each of the application's configuration parameters (this also applies to other system's sections).

@node Database administrator
@section Database administrator
@cindex administrator
@cindex administration

@node Configuration
@section Configuration
@cindex configuration

We provide a Domain Specific Language for configuration, so that can it can be read and edited with for example LSB or from a Web interface.
It is the same approach as for meta models.

Example:

@example
(define-configuration 'database-configuration ()
   (:title "Database configuration")
   (:documentation "Database configuration")
   (:section :database-configuration "Database configuration"
      (:documentation "Section for configuring the database")
      (:connection-type "Connection type"
          (one-of (:socket "Socket"
                       (:configuration 'db-socket-configuration))
                  (:tcp "TCP"
                       (:configuration 'db-tcp-configuration))))
      (:username "Username" :text :documentation "The database engine username")
      (:password "Password" :text :documentation "The database engine password")
      (:database-name "Database name" :text)
      (:database-parameters :text :default "" :advanced)))

(define-configuration 'db-socket-configuration ()
    (:title "Socket configuration")
    (:section :db-socket-configuration "Socket configuration"
        (:path "Socket" :text
               :default "/tmp/socket.soc")))

(define-configuration 'db-tcp-configuration ()
    (:title "TCP configuration")
    (:section "TCP configuration"
        (:url "URL" :text
              :default "localhost")))

(define-configuration webapp-configuration (logging-configuration)
    (:title "Web application configuration")
    (:documentation "Web application configuration")
    (:section :webapp-configuration "Web application configuration"
        (:documentation "Web application configuration")
        (:http-server "HTTP server"
            (one-of (:apache "Apache" (:configuration 'apache-configuration))
                    (:hunchentoot "Hunchentoot" (:configuration 'hunchentoot-configuration))))
        (:host "Host" :text :default "localhost")))

(define-configuration logging-configuration ()
    (:title "Logging configuration")
    (:documentation "Logging configuration")
    (let-configuration*
        ((output-logging ()
            (output-location "Output location"
                    (one-of (:standard-output "Standard output" :value '*standard-output*)
                            (:file "File" :text :default "/tmp/log.log"))))
        (debugging-layer (output-logging)
            (debugging-levels "Debuggin levels" (list (:info "Info")
                                                      (:warning "Warning")
                                                      (:profile "Profile"))))
        (database-layer (output-logging)
           ...)))
    (:section :logging-configuration "Logging configuration"
        (:documentation "Logging configuration")
        (:backend "Backend"
            (:one-of (:log5 "Log5")))
        (:active-layers "Active layers" (list (:debugging "Debugging" (:configuration debugging-layer))
                                              (:database "Database" (:configuration database-layer))
                                              (:control-flow "Control flow")
                                              (:system "System")))))

(define-configuration standard-configuration
                        (webapp-configuration database-configuration)
      (:documentation "Standard configuration for a Gestalt application")
      (:page-title "Page title" :type :text :default "Gestalt application"))

@end example

The typical attributes types are, :text, where the user fill text in; :one-of options*, where the user chooses one of the options in options*; :list list*, where the user selects one or more of the items of the list *list; :bool, a boolean, :maybe option, where the user can disable or enable option, etc.

Configurations can inherit from several configurations (that act like mixins). The same as with classes or models or templates. So, for example, web-app-configuration inherits from logging-configuration. That means the web-app-configuration will have the sections defined in logging-configuration too.

Documentation is used as a section or configuration help from the UI. From the UI, each section is shown collapsable and there's and option for showing/hiding advanced fields, and the help button.

The user can define several configuration schemes for an application and switch between the configurations. For example, there will probably be a ``development configuration'', a ``deployment configuration'', a ``testing configuration'', and so on.

There's no need for a GUI, although it is desirable. We can define configurations with files, for example:

@example
(define-configuration-scheme standard-configuration-scheme ()
   (:configuration standard-configuration)
   (:database-configuration
       (:connection-type :socket
           (:db-socket-configuration
              (:path "/tmp/my-socket.soc")))
       (:username "root")
       (:password "root")
       (:database-name "standard-database"))
   (:webapp-configuration
       (:host "localhost")
       (:http-server :hunchentoot)))

(define-configuration-scheme debug-configuration-scheme (standard-configuration-scheme)
    (:configuration standard-configuration)
    (:database-configuration
        (:database-name "debug-database"))
    (:logging-configuration
       (:output-location :file "/tmp/debug.log")
       (:active-layers :debugging :database
           (:debugging-levels :info :warning :error)))
    (:documentation "Debugging configuration scheme"))

(define-configuration-scheme test-configuration-scheme (standard-configuration-scheme)
    (:configuration standard-configuration)
    (:database-configuration
        (:database-name "test-database"))
    (:logging-configuration
       (:output-location :file "/tmp/test.log")
       (:active-layers :debugging :database
           (:debugging-levels :warning :error)))
    (:documentation "Testing configuration scheme"))
@end example

And then we attach the desired configuration to the application:

@example
(defapplication my-application (standard-application)
   ...
   (:configuration 'debug-configuration-scheme))
@end example

@node Debugging
@section Debugging
@cindex debugging

@node Inspector
@section Inspector
@cindex inspector

@node Profiling
@section Profiling
@cindex profiling

@node Deployment
@section Deployment
@cindex deployment

@node System reference
@chapter System reference

@include references/class-gst.view.xml-append-child-modification.texinfo
@include references/class-gst.view.xml-insert-child-modification.texinfo
@include references/class-gst.view.xml-remove-child-modification.texinfo
@include references/class-gst.view.xml-replace-child-modification.texinfo
@include references/class-gst.view.xml-tracked-xml-node.texinfo
@include references/class-gst.view.xml-xml-container.texinfo
@include references/class-gst.view.xml-xml-node-modification.texinfo
@include references/class-gst.view.xml-xml-node.texinfo
@include references/compiler-macro-gst.view.xml-children.texinfo
@include references/compiler-macro-gst.view.xml-do-children.texinfo
@include references/compiler-macro-gst.view.xml-is-appended.texinfo
@include references/compiler-macro-gst.view.xml-setf-children.texinfo
@include references/compiler-macro-gst.view.xml-setf-do-children.texinfo
@include references/compiler-macro-gst.view.xml-setf-is-appended.texinfo
@include references/fun-gst.view.xml-append-child.texinfo
@include references/fun-gst.view.xml-children.texinfo
@include references/fun-gst.view.xml-comes-after.texinfo
@include references/fun-gst.view.xml-comes-before.texinfo
@include references/fun-gst.view.xml-copy-xml-tree.texinfo
@include references/fun-gst.view.xml-insert-child-after.texinfo
@include references/fun-gst.view.xml-insert-child-before.texinfo
@include references/fun-gst.view.xml-insert-child.texinfo
@include references/fun-gst.view.xml-is-appended.texinfo
@include references/fun-gst.view.xml-is-next.texinfo
@include references/fun-gst.view.xml-is-previous.texinfo
@include references/fun-gst.view.xml-make-base-tree-node.texinfo
@include references/fun-gst.view.xml-make-base-tree.texinfo
@include references/fun-gst.view.xml-remove-child.texinfo
@include references/fun-gst.view.xml-replace-child.texinfo
@include references/fun-gst.view.xml-setf-children.texinfo
@include references/fun-gst.view.xml-xml-node-equal.texinfo
@include references/fun-gst.view.xml-xml-tree-equal.texinfo
@include references/macro-gst.view.xml-do-children.texinfo
@include references/method-combination-gst.view.xml-children.texinfo
@include references/method-combination-gst.view.xml-do-children.texinfo
@include references/method-combination-gst.view.xml-is-appended.texinfo
@include references/method-combination-gst.view.xml-setf-children.texinfo
@include references/method-combination-gst.view.xml-setf-do-children.texinfo
@include references/method-combination-gst.view.xml-setf-is-appended.texinfo
@include references/nil-gst.view.xml-setf-do-children.texinfo
@include references/nil-gst.view.xml-setf-is-appended.texinfo
@include references/package-gst.view.xml.texinfo
@include references/setf-expander-gst.view.xml-children.texinfo
@include references/setf-expander-gst.view.xml-do-children.texinfo
@include references/setf-expander-gst.view.xml-is-appended.texinfo
@include references/setf-expander-gst.view.xml-setf-children.texinfo
@include references/setf-expander-gst.view.xml-setf-do-children.texinfo
@include references/setf-expander-gst.view.xml-setf-is-appended.texinfo
@include references/type-gst.view.xml-children.texinfo
@include references/type-gst.view.xml-do-children.texinfo
@include references/type-gst.view.xml-is-appended.texinfo
@include references/type-gst.view.xml-setf-children.texinfo
@include references/type-gst.view.xml-setf-do-children.texinfo
@include references/type-gst.view.xml-setf-is-appended.texinfo
@include references/var-gst.view.xml-children.texinfo
@include references/var-gst.view.xml-do-children.texinfo
@include references/var-gst.view.xml-is-appended.texinfo
@include references/var-gst.view.xml-setf-children.texinfo
@include references/var-gst.view.xml-setf-do-children.texinfo
@include references/var-gst.view.xml-setf-is-appended.texinfo
@include references/var-gst.view.xml-star-register-modifications-star.texinfo

@node References
@chapter References
@cindex reference

 [Common Lisp Directory]

  [Smalltalk Seaside Web Framework]

  [Common Lisp Wiki]

  [Cells - A Common Lisp dataflow extension]

  [[http://common-lisp.net/project/elephant][Elephant - A Common Lisp object database]

  [Common Lisp Directory]: http://common-lisp.net
  [Smalltalk Seaside Web Framework]: http://seaside.st
  [Common Lisp Wiki]: http://www.cliki.net
  [Cells - A Common Lisp dataflow extension]: http://common-lisp.net/project/cells

@node Index
@chapter Index
@menu
* Concept Index::          The concept index
* Class Index::            The classes index
* Function / Macro Index:: The functions and macros index
* Variable Index::         The variables index
@end menu

@node Concept Index
@section Concept Index

@printindex cp

@node Class Index
@section Class Index

@printindex tp

@node Function / Macro Index
@section Function / Macro Index

@printindex fn

@node Variable Index
@section Variable Index

@printindex vr

@bye
